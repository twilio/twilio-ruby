##
# This code was generated by
# \ / _    _  _|   _  _
#  | (_)\/(_)(_|\/| |(/_  v1.0.0
#       /       /

module Twilio
  module TwiML
    ##
    # <Response> TwiML for Voice
    class VoiceResponse < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Response'

        yield(self) if block_given?
      end

      ##
      # Create a new <Dial> element
      # number:: Phone number to dial
      # action:: Action URL
      # method:: Action URL method
      # timeout:: Time to wait for answer
      # hangup_on_star:: Hangup call on star press
      # time_limit:: Max time length
      # caller_id:: Caller ID to display
      # record:: Record the call
      # trim:: Trim the recording
      # recording_status_callback:: Recording status callback URL
      # recording_status_callback_method:: Recording status callback URL method
      # answer_on_bridge:: Preserve the ringing behavior of the inbound call until the Dialed call picks up
      # ring_tone:: Ringtone allows you to override the ringback tone that Twilio will play back to the caller while executing the Dial
      # keyword_args:: additional attributes
      def dial(number: nil, action: nil, method: nil, timeout: nil, hangup_on_star: nil, time_limit: nil, caller_id: nil, record: nil, trim: nil, recording_status_callback: nil, recording_status_callback_method: nil, answer_on_bridge: nil, ring_tone: nil, **keyword_args)
        dial = Dial.new(number: number, action: action, method: method, timeout: timeout, hangup_on_star: hangup_on_star, time_limit: time_limit, caller_id: caller_id, record: record, trim: trim, recording_status_callback: recording_status_callback, recording_status_callback_method: recording_status_callback_method, answer_on_bridge: answer_on_bridge, ring_tone: ring_tone, **keyword_args)

        yield(dial) if block_given?
        append(dial)
      end

      ##
      # Create a new <Echo> element
      # keyword_args:: additional attributes
      def echo(**keyword_args)
        append(Echo.new(**keyword_args))
      end

      ##
      # Create a new <Enqueue> element
      # name:: Friendly name
      # action:: Action URL
      # method:: Action URL method
      # wait_url:: Wait URL
      # wait_url_method:: Wait URL method
      # workflow_sid:: TaskRouter Workflow SID
      # keyword_args:: additional attributes
      def enqueue(name: nil, action: nil, method: nil, wait_url: nil, wait_url_method: nil, workflow_sid: nil, **keyword_args)
        enqueue = Enqueue.new(name: name, action: action, method: method, wait_url: wait_url, wait_url_method: wait_url_method, workflow_sid: workflow_sid, **keyword_args)

        yield(enqueue) if block_given?
        append(enqueue)
      end

      ##
      # Create a new <Gather> element
      # input:: Input type Twilio should accept
      # action:: Action URL
      # method:: Action URL method
      # timeout:: Time to wait to gather input
      # speech_timeout:: Time to wait to gather speech input and it should be either auto or a positive integer.
      # max_speech_time:: Max allowed time for speech input
      # profanity_filter:: Profanity Filter on speech
      # finish_on_key:: Finish gather on key
      # num_digits:: Number of digits to collect
      # partial_result_callback:: Partial result callback URL
      # partial_result_callback_method:: Partial result callback URL method
      # language:: Language to use
      # hints:: Speech recognition hints
      # barge_in:: Stop playing media upon speech
      # keyword_args:: additional attributes
      def gather(input: nil, action: nil, method: nil, timeout: nil, speech_timeout: nil, max_speech_time: nil, profanity_filter: nil, finish_on_key: nil, num_digits: nil, partial_result_callback: nil, partial_result_callback_method: nil, language: nil, hints: nil, barge_in: nil, **keyword_args)
        gather = Gather.new(input: input, action: action, method: method, timeout: timeout, speech_timeout: speech_timeout, max_speech_time: max_speech_time, profanity_filter: profanity_filter, finish_on_key: finish_on_key, num_digits: num_digits, partial_result_callback: partial_result_callback, partial_result_callback_method: partial_result_callback_method, language: language, hints: hints, barge_in: barge_in, **keyword_args)

        yield(gather) if block_given?
        append(gather)
      end

      ##
      # Create a new <Hangup> element
      # keyword_args:: additional attributes
      def hangup(**keyword_args)
        append(Hangup.new(**keyword_args))
      end

      ##
      # Create a new <Leave> element
      # keyword_args:: additional attributes
      def leave(**keyword_args)
        append(Leave.new(**keyword_args))
      end

      ##
      # Create a new <Pause> element
      # length:: Length in seconds to pause
      # keyword_args:: additional attributes
      def pause(length: nil, **keyword_args)
        append(Pause.new(length: length, **keyword_args))
      end

      ##
      # Create a new <Play> element
      # url:: Media URL
      # loop:: Times to loop media
      # digits:: Play DTMF tones for digits
      # keyword_args:: additional attributes
      def play(url: nil, loop: nil, digits: nil, **keyword_args)
        append(Play.new(url: url, loop: loop, digits: digits, **keyword_args))
      end

      ##
      # Create a new <Queue> element
      # name:: Queue name
      # url:: Action URL
      # method:: Action URL method
      # reservation_sid:: TaskRouter Reservation SID
      # post_work_activity_sid:: TaskRouter Activity SID
      # keyword_args:: additional attributes
      def queue(name, url: nil, method: nil, reservation_sid: nil, post_work_activity_sid: nil, **keyword_args)
        append(Queue.new(name, url: url, method: method, reservation_sid: reservation_sid, post_work_activity_sid: post_work_activity_sid, **keyword_args))
      end

      ##
      # Create a new <Record> element
      # action:: Action URL
      # method:: Action URL method
      # timeout:: Timeout to begin recording
      # finish_on_key:: Finish recording on key
      # max_length:: Max time to record in seconds
      # play_beep:: Play beep
      # trim:: Trim the recording
      # recording_status_callback:: Status callback URL
      # recording_status_callback_method:: Status callback URL method
      # transcribe:: Transcribe the recording
      # transcribe_callback:: Transcribe callback URL
      # keyword_args:: additional attributes
      def record(action: nil, method: nil, timeout: nil, finish_on_key: nil, max_length: nil, play_beep: nil, trim: nil, recording_status_callback: nil, recording_status_callback_method: nil, transcribe: nil, transcribe_callback: nil, **keyword_args)
        append(Record.new(action: action, method: method, timeout: timeout, finish_on_key: finish_on_key, max_length: max_length, play_beep: play_beep, trim: trim, recording_status_callback: recording_status_callback, recording_status_callback_method: recording_status_callback_method, transcribe: transcribe, transcribe_callback: transcribe_callback, **keyword_args))
      end

      ##
      # Create a new <Redirect> element
      # url:: Redirect URL
      # method:: Redirect URL method
      # keyword_args:: additional attributes
      def redirect(url, method: nil, **keyword_args)
        append(Redirect.new(url, method: method, **keyword_args))
      end

      ##
      # Create a new <Reject> element
      # reason:: Rejection reason
      # keyword_args:: additional attributes
      def reject(reason: nil, **keyword_args)
        append(Reject.new(reason: reason, **keyword_args))
      end

      ##
      # Create a new <Say> element
      # message:: Message to say
      # voice:: Voice to use
      # loop:: Times to loop message
      # language:: Message langauge
      # keyword_args:: additional attributes
      def say(message, voice: nil, loop: nil, language: nil, **keyword_args)
        append(Say.new(message, voice: voice, loop: loop, language: language, **keyword_args))
      end

      ##
      # Create a new <Sms> element
      # message:: Message body
      # to:: Number to send message to
      # from:: Number to send message from
      # action:: Action URL
      # method:: Action URL method
      # status_callback:: Status callback URL
      # keyword_args:: additional attributes
      def sms(message, to: nil, from: nil, action: nil, method: nil, status_callback: nil, **keyword_args)
        append(Sms.new(message, to: to, from: from, action: action, method: method, status_callback: status_callback, **keyword_args))
      end
    end

    ##
    # <Sms> TwiML Noun
    class Sms < TwiML
      def initialize(message, **keyword_args)
        super(**keyword_args)
        @name = 'Sms'
        @value = message
        yield(self) if block_given?
      end
    end

    ##
    # <Say> TwiML Verb
    class Say < TwiML
      def initialize(message, **keyword_args)
        super(**keyword_args)
        @name = 'Say'
        @value = message
        yield(self) if block_given?
      end
    end

    ##
    # <Reject> TwiML Verb
    class Reject < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Reject'

        yield(self) if block_given?
      end
    end

    ##
    # <Redirect> TwiML Verb
    class Redirect < TwiML
      def initialize(url, **keyword_args)
        super(**keyword_args)
        @name = 'Redirect'
        @value = url
        yield(self) if block_given?
      end
    end

    ##
    # <Record> TwiML Verb
    class Record < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Record'

        yield(self) if block_given?
      end
    end

    ##
    # <Queue> TwiML Noun
    class Queue < TwiML
      def initialize(name, **keyword_args)
        super(**keyword_args)
        @name = 'Queue'
        @value = name
        yield(self) if block_given?
      end
    end

    ##
    # <Play> TwiML Verb
    class Play < TwiML
      def initialize(url: nil, **keyword_args)
        super(**keyword_args)
        @name = 'Play'
        @value = url unless url.nil?
        yield(self) if block_given?
      end
    end

    ##
    # <Pause> TwiML Verb
    class Pause < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Pause'

        yield(self) if block_given?
      end
    end

    ##
    # <Leave> TwiML Verb
    class Leave < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Leave'

        yield(self) if block_given?
      end
    end

    ##
    # <Hangup> TwiML Verb
    class Hangup < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Hangup'

        yield(self) if block_given?
      end
    end

    ##
    # <Gather> TwiML Verb
    class Gather < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Gather'

        yield(self) if block_given?
      end

      ##
      # Create a new <Say> element
      # message:: Message to say
      # voice:: Voice to use
      # loop:: Times to loop message
      # language:: Message langauge
      # keyword_args:: additional attributes
      def say(message, voice: nil, loop: nil, language: nil, **keyword_args)
        append(Say.new(message, voice: voice, loop: loop, language: language, **keyword_args))
      end

      ##
      # Create a new <Pause> element
      # length:: Length in seconds to pause
      # keyword_args:: additional attributes
      def pause(length: nil, **keyword_args)
        append(Pause.new(length: length, **keyword_args))
      end

      ##
      # Create a new <Play> element
      # url:: Media URL
      # loop:: Times to loop media
      # digits:: Play DTMF tones for digits
      # keyword_args:: additional attributes
      def play(url: nil, loop: nil, digits: nil, **keyword_args)
        append(Play.new(url: url, loop: loop, digits: digits, **keyword_args))
      end
    end

    ##
    # <Enqueue> TwiML Noun
    class Enqueue < TwiML
      def initialize(name: nil, **keyword_args)
        super(**keyword_args)
        @name = 'Enqueue'
        @value = name unless name.nil?
        yield(self) if block_given?
      end

      ##
      # Create a new <Task> element
      # body:: TaskRouter task attributes
      # keyword_args:: additional attributes
      def task(body, **keyword_args)
        append(Task.new(body, **keyword_args))
      end
    end

    ##
    # <Task> TwiML Noun
    class Task < TwiML
      def initialize(body, **keyword_args)
        super(**keyword_args)
        @name = 'Task'
        @value = body
        yield(self) if block_given?
      end
    end

    ##
    # <Echo> TwiML Verb
    class Echo < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Echo'

        yield(self) if block_given?
      end
    end

    ##
    # <Dial> TwiML Verb
    class Dial < TwiML
      def initialize(number: nil, **keyword_args)
        super(**keyword_args)
        @name = 'Dial'
        @value = number unless number.nil?
        yield(self) if block_given?
      end

      ##
      # Create a new <Client> element
      # name:: Client name
      # url:: Client URL
      # method:: Client URL Method
      # status_callback_event:: Events to trigger status callback
      # status_callback:: Status Callback URL
      # status_callback_method:: Status Callback URL Method
      # keyword_args:: additional attributes
      def client(name, url: nil, method: nil, status_callback_event: nil, status_callback: nil, status_callback_method: nil, **keyword_args)
        append(Client.new(name, url: url, method: method, status_callback_event: status_callback_event, status_callback: status_callback, status_callback_method: status_callback_method, **keyword_args))
      end

      ##
      # Create a new <Conference> element
      # name:: Conference name
      # muted:: Join the conference muted
      # beep:: Play beep when joining
      # start_conference_on_enter:: Start the conference on enter
      # end_conference_on_exit:: End the conferenceon exit
      # wait_url:: Wait URL
      # wait_method:: Wait URL method
      # max_participants:: Maximum number of participants
      # record:: Record the conference
      # region:: Conference region
      # whisper:: Call whisper
      # trim:: Trim the conference recording
      # status_callback_event:: Events to call status callback URL
      # status_callback:: Status callback URL
      # status_callback_method:: Status callback URL method
      # recording_status_callback:: Recording status callback URL
      # recording_status_callback_method:: Recording status callback URL method
      # event_callback_url:: Event callback URL
      # keyword_args:: additional attributes
      def conference(name, muted: nil, beep: nil, start_conference_on_enter: nil, end_conference_on_exit: nil, wait_url: nil, wait_method: nil, max_participants: nil, record: nil, region: nil, whisper: nil, trim: nil, status_callback_event: nil, status_callback: nil, status_callback_method: nil, recording_status_callback: nil, recording_status_callback_method: nil, event_callback_url: nil, **keyword_args)
        append(Conference.new(name, muted: muted, beep: beep, start_conference_on_enter: start_conference_on_enter, end_conference_on_exit: end_conference_on_exit, wait_url: wait_url, wait_method: wait_method, max_participants: max_participants, record: record, region: region, whisper: whisper, trim: trim, status_callback_event: status_callback_event, status_callback: status_callback, status_callback_method: status_callback_method, recording_status_callback: recording_status_callback, recording_status_callback_method: recording_status_callback_method, event_callback_url: event_callback_url, **keyword_args))
      end

      ##
      # Create a new <Number> element
      # phone_number:: Phone Number to dial
      # send_digits:: DTMF tones to play when the call is answered
      # url:: TwiML URL
      # method:: TwiML URL method
      # status_callback_event:: Events to call status callback
      # status_callback:: Status callback URL
      # status_callback_method:: Status callback URL method
      # keyword_args:: additional attributes
      def number(phone_number, send_digits: nil, url: nil, method: nil, status_callback_event: nil, status_callback: nil, status_callback_method: nil, **keyword_args)
        append(Number.new(phone_number, send_digits: send_digits, url: url, method: method, status_callback_event: status_callback_event, status_callback: status_callback, status_callback_method: status_callback_method, **keyword_args))
      end

      ##
      # Create a new <Queue> element
      # name:: Queue name
      # url:: Action URL
      # method:: Action URL method
      # reservation_sid:: TaskRouter Reservation SID
      # post_work_activity_sid:: TaskRouter Activity SID
      # keyword_args:: additional attributes
      def queue(name, url: nil, method: nil, reservation_sid: nil, post_work_activity_sid: nil, **keyword_args)
        append(Queue.new(name, url: url, method: method, reservation_sid: reservation_sid, post_work_activity_sid: post_work_activity_sid, **keyword_args))
      end

      ##
      # Create a new <Sim> element
      # sim_sid:: SIM SID
      # keyword_args:: additional attributes
      def sim(sim_sid, **keyword_args)
        append(Sim.new(sim_sid, **keyword_args))
      end

      ##
      # Create a new <Sip> element
      # sip_url:: SIP URL
      # username:: SIP Username
      # password:: SIP Password
      # url:: Action URL
      # method:: Action URL method
      # status_callback_event:: Status callback events
      # status_callback:: Status callback URL
      # status_callback_method:: Status callback URL method
      # keyword_args:: additional attributes
      def sip(sip_url, username: nil, password: nil, url: nil, method: nil, status_callback_event: nil, status_callback: nil, status_callback_method: nil, **keyword_args)
        append(Sip.new(sip_url, username: username, password: password, url: url, method: method, status_callback_event: status_callback_event, status_callback: status_callback, status_callback_method: status_callback_method, **keyword_args))
      end
    end

    ##
    # <Sip> TwiML Noun
    class Sip < TwiML
      def initialize(sip_url, **keyword_args)
        super(**keyword_args)
        @name = 'Sip'
        @value = sip_url
        yield(self) if block_given?
      end
    end

    ##
    # <Sim> TwiML Noun
    class Sim < TwiML
      def initialize(sim_sid, **keyword_args)
        super(**keyword_args)
        @name = 'Sim'
        @value = sim_sid
        yield(self) if block_given?
      end
    end

    ##
    # <Number> TwiML Noun
    class Number < TwiML
      def initialize(phone_number, **keyword_args)
        super(**keyword_args)
        @name = 'Number'
        @value = phone_number
        yield(self) if block_given?
      end
    end

    ##
    # <Conference> TwiML Noun
    class Conference < TwiML
      def initialize(name, **keyword_args)
        super(**keyword_args)
        @name = 'Conference'
        @value = name
        yield(self) if block_given?
      end
    end

    ##
    # <Client> TwiML Noun
    class Client < TwiML
      def initialize(name, **keyword_args)
        super(**keyword_args)
        @name = 'Client'
        @value = name
        yield(self) if block_given?
      end
    end
  end
end