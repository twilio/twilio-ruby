##
# This code was generated by
# \ / _    _  _|   _  _
#  | (_)\/(_)(_|\/| |(/_  v1.0.0
#       /       /
#
# frozen_string_literal: true

module Twilio
  module TwiML
    ##
    # <Response> TwiML for Voice
    class VoiceResponse < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Response'

        yield(self) if block_given?
      end

      ##
      # Create a new <Connect> element
      # action:: Action URL
      # method:: Action URL method
      # keyword_args:: additional attributes
      def connect(action: nil, method: nil, **keyword_args)
        connect = Connect.new(action: action, method: method, **keyword_args)

        yield(connect) if block_given?
        append(connect)
      end

      ##
      # Create a new <Dial> element
      # number:: Phone number to dial
      # action:: Action URL
      # method:: Action URL method
      # timeout:: Time to wait for answer
      # hangup_on_star:: Hangup call on star press
      # time_limit:: Max time length
      # caller_id:: Caller ID to display
      # record:: Record the call
      # trim:: Trim the recording
      # recording_status_callback:: Recording status callback URL
      # recording_status_callback_method:: Recording status callback URL method
      # recording_status_callback_event:: Recording status callback events
      # answer_on_bridge:: Preserve the ringing behavior of the inbound call until the Dialed call picks up
      # ring_tone:: Ringtone allows you to override the ringback tone that Twilio will play back to the caller while executing the Dial
      # recording_track:: To indicate which audio track should be recorded
      # sequential:: Used to determine if child TwiML nouns should be dialed in order, one after the other (sequential) or dial all at once (parallel). Default is false, parallel
      # keyword_args:: additional attributes
      def dial(number: nil, action: nil, method: nil, timeout: nil, hangup_on_star: nil, time_limit: nil, caller_id: nil, record: nil, trim: nil, recording_status_callback: nil, recording_status_callback_method: nil, recording_status_callback_event: nil, answer_on_bridge: nil, ring_tone: nil, recording_track: nil, sequential: nil, **keyword_args)
        dial = Dial.new(number: number, action: action, method: method, timeout: timeout, hangup_on_star: hangup_on_star, time_limit: time_limit, caller_id: caller_id, record: record, trim: trim, recording_status_callback: recording_status_callback, recording_status_callback_method: recording_status_callback_method, recording_status_callback_event: recording_status_callback_event, answer_on_bridge: answer_on_bridge, ring_tone: ring_tone, recording_track: recording_track, sequential: sequential, **keyword_args)

        yield(dial) if block_given?
        append(dial)
      end

      ##
      # Create a new <Echo> element
      # keyword_args:: additional attributes
      def echo(**keyword_args)
        append(Echo.new(**keyword_args))
      end

      ##
      # Create a new <Enqueue> element
      # name:: Friendly name
      # action:: Action URL
      # method:: Action URL method
      # wait_url:: Wait URL
      # wait_url_method:: Wait URL method
      # workflow_sid:: TaskRouter Workflow SID
      # keyword_args:: additional attributes
      def enqueue(name: nil, action: nil, method: nil, wait_url: nil, wait_url_method: nil, workflow_sid: nil, **keyword_args)
        enqueue = Enqueue.new(name: name, action: action, method: method, wait_url: wait_url, wait_url_method: wait_url_method, workflow_sid: workflow_sid, **keyword_args)

        yield(enqueue) if block_given?
        append(enqueue)
      end

      ##
      # Create a new <Gather> element
      # input:: Input type Twilio should accept
      # action:: Action URL
      # method:: Action URL method
      # timeout:: Time to wait to gather input
      # speech_timeout:: Time to wait to gather speech input and it should be either auto or a positive integer.
      # max_speech_time:: Max allowed time for speech input
      # profanity_filter:: Profanity Filter on speech
      # finish_on_key:: Finish gather on key
      # num_digits:: Number of digits to collect
      # partial_result_callback:: Partial result callback URL
      # partial_result_callback_method:: Partial result callback URL method
      # language:: Language to use
      # hints:: Speech recognition hints
      # barge_in:: Stop playing media upon speech
      # debug:: Allow debug for gather
      # action_on_empty_result:: Force webhook to the action URL event if there is no input
      # speech_model:: Specify the model that is best suited for your use case
      # enhanced:: Use enhanced speech model
      # keyword_args:: additional attributes
      def gather(input: nil, action: nil, method: nil, timeout: nil, speech_timeout: nil, max_speech_time: nil, profanity_filter: nil, finish_on_key: nil, num_digits: nil, partial_result_callback: nil, partial_result_callback_method: nil, language: nil, hints: nil, barge_in: nil, debug: nil, action_on_empty_result: nil, speech_model: nil, enhanced: nil, **keyword_args)
        gather = Gather.new(input: input, action: action, method: method, timeout: timeout, speech_timeout: speech_timeout, max_speech_time: max_speech_time, profanity_filter: profanity_filter, finish_on_key: finish_on_key, num_digits: num_digits, partial_result_callback: partial_result_callback, partial_result_callback_method: partial_result_callback_method, language: language, hints: hints, barge_in: barge_in, debug: debug, action_on_empty_result: action_on_empty_result, speech_model: speech_model, enhanced: enhanced, **keyword_args)

        yield(gather) if block_given?
        append(gather)
      end

      ##
      # Create a new <Hangup> element
      # keyword_args:: additional attributes
      def hangup(**keyword_args)
        append(Hangup.new(**keyword_args))
      end

      ##
      # Create a new <Leave> element
      # keyword_args:: additional attributes
      def leave(**keyword_args)
        append(Leave.new(**keyword_args))
      end

      ##
      # Create a new <Pause> element
      # length:: Length in seconds to pause
      # keyword_args:: additional attributes
      def pause(length: nil, **keyword_args)
        append(Pause.new(length: length, **keyword_args))
      end

      ##
      # Create a new <Play> element
      # url:: Media URL
      # loop:: Times to loop media
      # digits:: Play DTMF tones for digits
      # keyword_args:: additional attributes
      def play(url: nil, loop: nil, digits: nil, **keyword_args)
        append(Play.new(url: url, loop: loop, digits: digits, **keyword_args))
      end

      ##
      # Create a new <Queue> element
      # name:: Queue name
      # url:: Action URL
      # method:: Action URL method
      # reservation_sid:: TaskRouter Reservation SID
      # post_work_activity_sid:: TaskRouter Activity SID
      # keyword_args:: additional attributes
      def queue(name, url: nil, method: nil, reservation_sid: nil, post_work_activity_sid: nil, **keyword_args)
        append(Queue.new(name, url: url, method: method, reservation_sid: reservation_sid, post_work_activity_sid: post_work_activity_sid, **keyword_args))
      end

      ##
      # Create a new <Record> element
      # action:: Action URL
      # method:: Action URL method
      # timeout:: Timeout to begin recording
      # finish_on_key:: Finish recording on key
      # max_length:: Max time to record in seconds
      # play_beep:: Play beep
      # trim:: Trim the recording
      # recording_status_callback:: Status callback URL
      # recording_status_callback_method:: Status callback URL method
      # recording_status_callback_event:: Recording status callback events
      # transcribe:: Transcribe the recording
      # transcribe_callback:: Transcribe callback URL
      # keyword_args:: additional attributes
      def record(action: nil, method: nil, timeout: nil, finish_on_key: nil, max_length: nil, play_beep: nil, trim: nil, recording_status_callback: nil, recording_status_callback_method: nil, recording_status_callback_event: nil, transcribe: nil, transcribe_callback: nil, **keyword_args)
        append(Record.new(action: action, method: method, timeout: timeout, finish_on_key: finish_on_key, max_length: max_length, play_beep: play_beep, trim: trim, recording_status_callback: recording_status_callback, recording_status_callback_method: recording_status_callback_method, recording_status_callback_event: recording_status_callback_event, transcribe: transcribe, transcribe_callback: transcribe_callback, **keyword_args))
      end

      ##
      # Create a new <Redirect> element
      # url:: Redirect URL
      # method:: Redirect URL method
      # keyword_args:: additional attributes
      def redirect(url, method: nil, **keyword_args)
        append(Redirect.new(url, method: method, **keyword_args))
      end

      ##
      # Create a new <Reject> element
      # reason:: Rejection reason
      # keyword_args:: additional attributes
      def reject(reason: nil, **keyword_args)
        append(Reject.new(reason: reason, **keyword_args))
      end

      ##
      # Create a new <Say> element
      # message:: Message to say
      # voice:: Voice to use
      # loop:: Times to loop message
      # language:: Message langauge
      # keyword_args:: additional attributes
      def say(message: nil, voice: nil, loop: nil, language: nil, **keyword_args)
        say = Say.new(message: message, voice: voice, loop: loop, language: language, **keyword_args)

        yield(say) if block_given?
        append(say)
      end

      ##
      # Create a new <Sms> element
      # message:: Message body
      # to:: Number to send message to
      # from:: Number to send message from
      # action:: Action URL
      # method:: Action URL method
      # status_callback:: Status callback URL
      # keyword_args:: additional attributes
      def sms(message, to: nil, from: nil, action: nil, method: nil, status_callback: nil, **keyword_args)
        append(Sms.new(message, to: to, from: from, action: action, method: method, status_callback: status_callback, **keyword_args))
      end

      ##
      # Create a new <Pay> element
      # input:: Input type Twilio should accept
      # action:: Action URL
      # bank_account_type:: Bank account type for ach transactions. If set, payment method attribute must be provided and value should be set to ach-debit. defaults to consumer-checking
      # status_callback:: Status callback URL
      # status_callback_method:: Status callback method
      # timeout:: Time to wait to gather input
      # max_attempts:: Maximum number of allowed retries when gathering input
      # security_code:: Prompt for security code
      # postal_code:: Prompt for postal code and it should be true/false or default postal code
      # min_postal_code_length:: Prompt for minimum postal code length
      # payment_connector:: Unique name for payment connector
      # payment_method:: Payment method to be used. defaults to credit-card
      # token_type:: Type of token
      # charge_amount:: Amount to process. If value is greater than 0 then make the payment else create a payment token
      # currency:: Currency of the amount attribute
      # description:: Details regarding the payment
      # valid_card_types:: Comma separated accepted card types
      # language:: Language to use
      # keyword_args:: additional attributes
      def pay(input: nil, action: nil, bank_account_type: nil, status_callback: nil, status_callback_method: nil, timeout: nil, max_attempts: nil, security_code: nil, postal_code: nil, min_postal_code_length: nil, payment_connector: nil, payment_method: nil, token_type: nil, charge_amount: nil, currency: nil, description: nil, valid_card_types: nil, language: nil, **keyword_args)
        pay = Pay.new(input: input, action: action, bank_account_type: bank_account_type, status_callback: status_callback, status_callback_method: status_callback_method, timeout: timeout, max_attempts: max_attempts, security_code: security_code, postal_code: postal_code, min_postal_code_length: min_postal_code_length, payment_connector: payment_connector, payment_method: payment_method, token_type: token_type, charge_amount: charge_amount, currency: currency, description: description, valid_card_types: valid_card_types, language: language, **keyword_args)

        yield(pay) if block_given?
        append(pay)
      end

      ##
      # Create a new <Prompt> element
      # for_:: Name of the payment source data element
      # error_type:: Type of error
      # card_type:: Type of the credit card
      # attempt:: Current attempt count
      # keyword_args:: additional attributes
      def prompt(for_: nil, error_type: nil, card_type: nil, attempt: nil, **keyword_args)
        prompt = Prompt.new(for_: for_, error_type: error_type, card_type: card_type, attempt: attempt, **keyword_args)

        yield(prompt) if block_given?
        append(prompt)
      end

      ##
      # Create a new <Start> element
      # action:: Action URL
      # method:: Action URL method
      # keyword_args:: additional attributes
      def start(action: nil, method: nil, **keyword_args)
        start = Start.new(action: action, method: method, **keyword_args)

        yield(start) if block_given?
        append(start)
      end

      ##
      # Create a new <Stop> element
      # keyword_args:: additional attributes
      def stop(**keyword_args)
        stop = Stop.new(**keyword_args)

        yield(stop) if block_given?
        append(stop)
      end

      ##
      # Create a new <Refer> element
      # action:: Action URL
      # method:: Action URL method
      # keyword_args:: additional attributes
      def refer(action: nil, method: nil, **keyword_args)
        refer = Refer.new(action: action, method: method, **keyword_args)

        yield(refer) if block_given?
        append(refer)
      end
    end

    ##
    # <Refer> TwiML Verb
    class Refer < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Refer'

        yield(self) if block_given?
      end

      ##
      # Create a new <Sip> element
      # sip_url:: SIP URL
      # keyword_args:: additional attributes
      def sip(sip_url, **keyword_args)
        append(ReferSip.new(sip_url, **keyword_args))
      end
    end

    ##
    # <Sip> TwiML Noun used in <Refer>
    class ReferSip < TwiML
      def initialize(sip_url, **keyword_args)
        super(**keyword_args)
        @name = 'Sip'
        @value = sip_url
        yield(self) if block_given?
      end
    end

    ##
    # <Stop> TwiML Verb
    class Stop < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Stop'

        yield(self) if block_given?
      end

      ##
      # Create a new <Stream> element
      # name:: Friendly name given to the Stream
      # connector_name:: Unique name for Stream Connector
      # url:: URL of the remote service where the Stream is routed
      # track:: Track to be streamed to remote service
      # status_callback:: Status Callback URL
      # status_callback_method:: Status Callback URL method
      # keyword_args:: additional attributes
      def stream(name: nil, connector_name: nil, url: nil, track: nil, status_callback: nil, status_callback_method: nil, **keyword_args)
        stream = Stream.new(name: name, connector_name: connector_name, url: url, track: track, status_callback: status_callback, status_callback_method: status_callback_method, **keyword_args)

        yield(stream) if block_given?
        append(stream)
      end

      ##
      # Create a new <Siprec> element
      # name:: Friendly name given to SIPREC
      # connector_name:: Unique name for Connector
      # track:: Track to be streamed to remote service
      # keyword_args:: additional attributes
      def siprec(name: nil, connector_name: nil, track: nil, **keyword_args)
        siprec = Siprec.new(name: name, connector_name: connector_name, track: track, **keyword_args)

        yield(siprec) if block_given?
        append(siprec)
      end
    end

    ##
    # <Siprec> TwiML Noun
    class Siprec < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Siprec'

        yield(self) if block_given?
      end

      ##
      # Create a new <Parameter> element
      # name:: The name of the custom parameter
      # value:: The value of the custom parameter
      # keyword_args:: additional attributes
      def parameter(name: nil, value: nil, **keyword_args)
        append(Parameter.new(name: name, value: value, **keyword_args))
      end
    end

    ##
    # <Parameter> TwiML Noun
    class Parameter < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Parameter'

        yield(self) if block_given?
      end
    end

    ##
    # <Stream> TwiML Noun
    class Stream < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Stream'

        yield(self) if block_given?
      end

      ##
      # Create a new <Parameter> element
      # name:: The name of the custom parameter
      # value:: The value of the custom parameter
      # keyword_args:: additional attributes
      def parameter(name: nil, value: nil, **keyword_args)
        append(Parameter.new(name: name, value: value, **keyword_args))
      end
    end

    ##
    # <Start> TwiML Verb
    class Start < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Start'

        yield(self) if block_given?
      end

      ##
      # Create a new <Stream> element
      # name:: Friendly name given to the Stream
      # connector_name:: Unique name for Stream Connector
      # url:: URL of the remote service where the Stream is routed
      # track:: Track to be streamed to remote service
      # status_callback:: Status Callback URL
      # status_callback_method:: Status Callback URL method
      # keyword_args:: additional attributes
      def stream(name: nil, connector_name: nil, url: nil, track: nil, status_callback: nil, status_callback_method: nil, **keyword_args)
        stream = Stream.new(name: name, connector_name: connector_name, url: url, track: track, status_callback: status_callback, status_callback_method: status_callback_method, **keyword_args)

        yield(stream) if block_given?
        append(stream)
      end

      ##
      # Create a new <Siprec> element
      # name:: Friendly name given to SIPREC
      # connector_name:: Unique name for Connector
      # track:: Track to be streamed to remote service
      # keyword_args:: additional attributes
      def siprec(name: nil, connector_name: nil, track: nil, **keyword_args)
        siprec = Siprec.new(name: name, connector_name: connector_name, track: track, **keyword_args)

        yield(siprec) if block_given?
        append(siprec)
      end
    end

    ##
    # <Prompt> Twiml Verb
    class Prompt < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Prompt'

        yield(self) if block_given?
      end

      ##
      # Create a new <Say> element
      # message:: Message to say
      # voice:: Voice to use
      # loop:: Times to loop message
      # language:: Message langauge
      # keyword_args:: additional attributes
      def say(message: nil, voice: nil, loop: nil, language: nil, **keyword_args)
        say = Say.new(message: message, voice: voice, loop: loop, language: language, **keyword_args)

        yield(say) if block_given?
        append(say)
      end

      ##
      # Create a new <Play> element
      # url:: Media URL
      # loop:: Times to loop media
      # digits:: Play DTMF tones for digits
      # keyword_args:: additional attributes
      def play(url: nil, loop: nil, digits: nil, **keyword_args)
        append(Play.new(url: url, loop: loop, digits: digits, **keyword_args))
      end

      ##
      # Create a new <Pause> element
      # length:: Length in seconds to pause
      # keyword_args:: additional attributes
      def pause(length: nil, **keyword_args)
        append(Pause.new(length: length, **keyword_args))
      end
    end

    ##
    # <Pause> TwiML Verb
    class Pause < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Pause'

        yield(self) if block_given?
      end
    end

    ##
    # <Play> TwiML Verb
    class Play < TwiML
      def initialize(url: nil, **keyword_args)
        super(**keyword_args)
        @name = 'Play'
        @value = url unless url.nil?
        yield(self) if block_given?
      end
    end

    ##
    # <Say> TwiML Verb
    class Say < TwiML
      def initialize(message: nil, **keyword_args)
        super(**keyword_args)
        @name = 'Say'
        @value = message unless message.nil?
        yield(self) if block_given?
      end

      ##
      # Create a new <Break> element
      # strength:: Set a pause based on strength
      # time:: Set a pause to a specific length of time in seconds or milliseconds, available values: [number]s, [number]ms
      # keyword_args:: additional attributes
      def break(strength: nil, time: nil, **keyword_args)
        append(SsmlBreak.new(strength: strength, time: time, **keyword_args))
      end

      ##
      # Create a new <Emphasis> element
      # words:: Words to emphasize
      # level:: Specify the degree of emphasis
      # keyword_args:: additional attributes
      def emphasis(words, level: nil, **keyword_args)
        append(SsmlEmphasis.new(words, level: level, **keyword_args))
      end

      ##
      # Create a new <Lang> element
      # words:: Words to speak
      # xmlLang:: Specify the language
      # keyword_args:: additional attributes
      def lang(words, xmlLang: nil, **keyword_args)
        append(SsmlLang.new(words, xmlLang: xmlLang, **keyword_args))
      end

      ##
      # Create a new <P> element
      # words:: Words to speak
      # keyword_args:: additional attributes
      def p(words, **keyword_args)
        append(SsmlP.new(words, **keyword_args))
      end

      ##
      # Create a new <Phoneme> element
      # words:: Words to speak
      # alphabet:: Specify the phonetic alphabet
      # ph:: Specifiy the phonetic symbols for pronunciation
      # keyword_args:: additional attributes
      def phoneme(words, alphabet: nil, ph: nil, **keyword_args)
        append(SsmlPhoneme.new(words, alphabet: alphabet, ph: ph, **keyword_args))
      end

      ##
      # Create a new <Prosody> element
      # words:: Words to speak
      # volume:: Specify the volume, available values: default, silent, x-soft, soft, medium, loud, x-loud, +ndB, -ndB
      # rate:: Specify the rate, available values: x-slow, slow, medium, fast, x-fast, n%
      # pitch:: Specify the pitch, available values: default, x-low, low, medium, high, x-high, +n%, -n%
      # keyword_args:: additional attributes
      def prosody(words, volume: nil, rate: nil, pitch: nil, **keyword_args)
        append(SsmlProsody.new(words, volume: volume, rate: rate, pitch: pitch, **keyword_args))
      end

      ##
      # Create a new <S> element
      # words:: Words to speak
      # keyword_args:: additional attributes
      def s(words, **keyword_args)
        append(SsmlS.new(words, **keyword_args))
      end

      ##
      # Create a new <Say-As> element
      # words:: Words to be interpreted
      # interpretAs:: Specify the type of words are spoken
      # role:: Specify the format of the date when interpret-as is set to date
      # keyword_args:: additional attributes
      def say_as(words, interpretAs: nil, role: nil, **keyword_args)
        append(SsmlSayAs.new(words, interpretAs: interpretAs, role: role, **keyword_args))
      end

      ##
      # Create a new <Sub> element
      # words:: Words to be substituted
      # aliasAttribute:: Substitute a different word (or pronunciation) for selected text such as an acronym or abbreviation
      # keyword_args:: additional attributes
      def sub(words, aliasAttribute: nil, **keyword_args)
        append(SsmlSub.new(words, aliasAttribute: aliasAttribute, **keyword_args))
      end

      ##
      # Create a new <W> element
      # words:: Words to speak
      # role:: Customize the pronunciation of words by specifying the word’s part of speech or alternate meaning
      # keyword_args:: additional attributes
      def w(words, role: nil, **keyword_args)
        append(SsmlW.new(words, role: role, **keyword_args))
      end
    end

    ##
    # Improving Pronunciation by Specifying Parts of Speech in <Say>
    class SsmlW < TwiML
      def initialize(words, **keyword_args)
        super(**keyword_args)
        @name = 'w'
        @value = words
        yield(self) if block_given?
      end
    end

    ##
    # Pronouncing Acronyms and Abbreviations in <Say>
    class SsmlSub < TwiML
      def initialize(words, **keyword_args)
        super(**keyword_args)
        @name = 'sub'
        @value = words
        yield(self) if block_given?
      end
    end

    ##
    # Controlling How Special Types of Words Are Spoken in <Say>
    class SsmlSayAs < TwiML
      def initialize(words, **keyword_args)
        super(**keyword_args)
        @name = 'say-as'
        @value = words
        yield(self) if block_given?
      end
    end

    ##
    # Adding A Pause Between Sentences in <Say>
    class SsmlS < TwiML
      def initialize(words, **keyword_args)
        super(**keyword_args)
        @name = 's'
        @value = words
        yield(self) if block_given?
      end
    end

    ##
    # Controling Volume, Speaking Rate, and Pitch in <Say>
    class SsmlProsody < TwiML
      def initialize(words, **keyword_args)
        super(**keyword_args)
        @name = 'prosody'
        @value = words
        yield(self) if block_given?
      end
    end

    ##
    # Using Phonetic Pronunciation in <Say>
    class SsmlPhoneme < TwiML
      def initialize(words, **keyword_args)
        super(**keyword_args)
        @name = 'phoneme'
        @value = words
        yield(self) if block_given?
      end
    end

    ##
    # Adding a Pause Between Paragraphs in <Say>
    class SsmlP < TwiML
      def initialize(words, **keyword_args)
        super(**keyword_args)
        @name = 'p'
        @value = words
        yield(self) if block_given?
      end
    end

    ##
    # Specifying Another Language for Specific Words in <Say>
    class SsmlLang < TwiML
      def initialize(words, **keyword_args)
        super(**keyword_args)
        @name = 'lang'
        @value = words
        yield(self) if block_given?
      end
    end

    ##
    # Emphasizing Words in <Say>
    class SsmlEmphasis < TwiML
      def initialize(words, **keyword_args)
        super(**keyword_args)
        @name = 'emphasis'
        @value = words
        yield(self) if block_given?
      end
    end

    ##
    # Adding a Pause in <Say>
    class SsmlBreak < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'break'

        yield(self) if block_given?
      end
    end

    ##
    # <Pay> Twiml Verb
    class Pay < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Pay'

        yield(self) if block_given?
      end

      ##
      # Create a new <Prompt> element
      # for_:: Name of the payment source data element
      # error_type:: Type of error
      # card_type:: Type of the credit card
      # attempt:: Current attempt count
      # keyword_args:: additional attributes
      def prompt(for_: nil, error_type: nil, card_type: nil, attempt: nil, **keyword_args)
        prompt = Prompt.new(for_: for_, error_type: error_type, card_type: card_type, attempt: attempt, **keyword_args)

        yield(prompt) if block_given?
        append(prompt)
      end

      ##
      # Create a new <Parameter> element
      # name:: The name of the custom parameter
      # value:: The value of the custom parameter
      # keyword_args:: additional attributes
      def parameter(name: nil, value: nil, **keyword_args)
        append(Parameter.new(name: name, value: value, **keyword_args))
      end
    end

    ##
    # <Sms> TwiML Noun
    class Sms < TwiML
      def initialize(message, **keyword_args)
        super(**keyword_args)
        @name = 'Sms'
        @value = message
        yield(self) if block_given?
      end
    end

    ##
    # <Reject> TwiML Verb
    class Reject < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Reject'

        yield(self) if block_given?
      end
    end

    ##
    # <Redirect> TwiML Verb
    class Redirect < TwiML
      def initialize(url, **keyword_args)
        super(**keyword_args)
        @name = 'Redirect'
        @value = url
        yield(self) if block_given?
      end
    end

    ##
    # <Record> TwiML Verb
    class Record < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Record'

        yield(self) if block_given?
      end
    end

    ##
    # <Queue> TwiML Noun
    class Queue < TwiML
      def initialize(name, **keyword_args)
        super(**keyword_args)
        @name = 'Queue'
        @value = name
        yield(self) if block_given?
      end
    end

    ##
    # <Leave> TwiML Verb
    class Leave < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Leave'

        yield(self) if block_given?
      end
    end

    ##
    # <Hangup> TwiML Verb
    class Hangup < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Hangup'

        yield(self) if block_given?
      end
    end

    ##
    # <Gather> TwiML Verb
    class Gather < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Gather'

        yield(self) if block_given?
      end

      ##
      # Create a new <Say> element
      # message:: Message to say
      # voice:: Voice to use
      # loop:: Times to loop message
      # language:: Message langauge
      # keyword_args:: additional attributes
      def say(message: nil, voice: nil, loop: nil, language: nil, **keyword_args)
        say = Say.new(message: message, voice: voice, loop: loop, language: language, **keyword_args)

        yield(say) if block_given?
        append(say)
      end

      ##
      # Create a new <Pause> element
      # length:: Length in seconds to pause
      # keyword_args:: additional attributes
      def pause(length: nil, **keyword_args)
        append(Pause.new(length: length, **keyword_args))
      end

      ##
      # Create a new <Play> element
      # url:: Media URL
      # loop:: Times to loop media
      # digits:: Play DTMF tones for digits
      # keyword_args:: additional attributes
      def play(url: nil, loop: nil, digits: nil, **keyword_args)
        append(Play.new(url: url, loop: loop, digits: digits, **keyword_args))
      end
    end

    ##
    # <Enqueue> TwiML Noun
    class Enqueue < TwiML
      def initialize(name: nil, **keyword_args)
        super(**keyword_args)
        @name = 'Enqueue'
        @value = name unless name.nil?
        yield(self) if block_given?
      end

      ##
      # Create a new <Task> element
      # body:: TaskRouter task attributes
      # priority:: Task priority
      # timeout:: Timeout associated with task
      # keyword_args:: additional attributes
      def task(body, priority: nil, timeout: nil, **keyword_args)
        append(Task.new(body, priority: priority, timeout: timeout, **keyword_args))
      end
    end

    ##
    # <Task> TwiML Noun
    class Task < TwiML
      def initialize(body, **keyword_args)
        super(**keyword_args)
        @name = 'Task'
        @value = body
        yield(self) if block_given?
      end
    end

    ##
    # <Echo> TwiML Verb
    class Echo < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Echo'

        yield(self) if block_given?
      end
    end

    ##
    # <Dial> TwiML Verb
    class Dial < TwiML
      def initialize(number: nil, **keyword_args)
        super(**keyword_args)
        @name = 'Dial'
        @value = number unless number.nil?
        yield(self) if block_given?
      end

      ##
      # Create a new <Client> element
      # identity:: Client identity
      # url:: Client URL
      # method:: Client URL Method
      # status_callback_event:: Events to trigger status callback
      # status_callback:: Status Callback URL
      # status_callback_method:: Status Callback URL Method
      # keyword_args:: additional attributes
      def client(identity: nil, url: nil, method: nil, status_callback_event: nil, status_callback: nil, status_callback_method: nil, **keyword_args)
        client = Client.new(identity: identity, url: url, method: method, status_callback_event: status_callback_event, status_callback: status_callback, status_callback_method: status_callback_method, **keyword_args)

        yield(client) if block_given?
        append(client)
      end

      ##
      # Create a new <Conference> element
      # name:: Conference name
      # muted:: Join the conference muted
      # beep:: Play beep when joining
      # start_conference_on_enter:: Start the conference on enter
      # end_conference_on_exit:: End the conferenceon exit
      # wait_url:: Wait URL
      # wait_method:: Wait URL method
      # max_participants:: Maximum number of participants
      # record:: Record the conference
      # region:: Conference region
      # coach:: Call coach
      # trim:: Trim the conference recording
      # status_callback_event:: Events to call status callback URL
      # status_callback:: Status callback URL
      # status_callback_method:: Status callback URL method
      # recording_status_callback:: Recording status callback URL
      # recording_status_callback_method:: Recording status callback URL method
      # recording_status_callback_event:: Recording status callback events
      # event_callback_url:: Event callback URL
      # jitter_buffer_size:: Size of jitter buffer for participant
      # participant_label:: A label for participant
      # keyword_args:: additional attributes
      def conference(name, muted: nil, beep: nil, start_conference_on_enter: nil, end_conference_on_exit: nil, wait_url: nil, wait_method: nil, max_participants: nil, record: nil, region: nil, coach: nil, trim: nil, status_callback_event: nil, status_callback: nil, status_callback_method: nil, recording_status_callback: nil, recording_status_callback_method: nil, recording_status_callback_event: nil, event_callback_url: nil, jitter_buffer_size: nil, participant_label: nil, **keyword_args)
        append(Conference.new(name, muted: muted, beep: beep, start_conference_on_enter: start_conference_on_enter, end_conference_on_exit: end_conference_on_exit, wait_url: wait_url, wait_method: wait_method, max_participants: max_participants, record: record, region: region, coach: coach, trim: trim, status_callback_event: status_callback_event, status_callback: status_callback, status_callback_method: status_callback_method, recording_status_callback: recording_status_callback, recording_status_callback_method: recording_status_callback_method, recording_status_callback_event: recording_status_callback_event, event_callback_url: event_callback_url, jitter_buffer_size: jitter_buffer_size, participant_label: participant_label, **keyword_args))
      end

      ##
      # Create a new <Number> element
      # phone_number:: Phone Number to dial
      # send_digits:: DTMF tones to play when the call is answered
      # url:: TwiML URL
      # method:: TwiML URL method
      # status_callback_event:: Events to call status callback
      # status_callback:: Status callback URL
      # status_callback_method:: Status callback URL method
      # byoc:: BYOC trunk SID (Beta)
      # keyword_args:: additional attributes
      def number(phone_number, send_digits: nil, url: nil, method: nil, status_callback_event: nil, status_callback: nil, status_callback_method: nil, byoc: nil, **keyword_args)
        append(Number.new(phone_number, send_digits: send_digits, url: url, method: method, status_callback_event: status_callback_event, status_callback: status_callback, status_callback_method: status_callback_method, byoc: byoc, **keyword_args))
      end

      ##
      # Create a new <Queue> element
      # name:: Queue name
      # url:: Action URL
      # method:: Action URL method
      # reservation_sid:: TaskRouter Reservation SID
      # post_work_activity_sid:: TaskRouter Activity SID
      # keyword_args:: additional attributes
      def queue(name, url: nil, method: nil, reservation_sid: nil, post_work_activity_sid: nil, **keyword_args)
        append(Queue.new(name, url: url, method: method, reservation_sid: reservation_sid, post_work_activity_sid: post_work_activity_sid, **keyword_args))
      end

      ##
      # Create a new <Sim> element
      # sim_sid:: SIM SID
      # keyword_args:: additional attributes
      def sim(sim_sid, **keyword_args)
        append(Sim.new(sim_sid, **keyword_args))
      end

      ##
      # Create a new <Sip> element
      # sip_url:: SIP URL
      # username:: SIP Username
      # password:: SIP Password
      # url:: Action URL
      # method:: Action URL method
      # status_callback_event:: Status callback events
      # status_callback:: Status callback URL
      # status_callback_method:: Status callback URL method
      # keyword_args:: additional attributes
      def sip(sip_url, username: nil, password: nil, url: nil, method: nil, status_callback_event: nil, status_callback: nil, status_callback_method: nil, **keyword_args)
        append(Sip.new(sip_url, username: username, password: password, url: url, method: method, status_callback_event: status_callback_event, status_callback: status_callback, status_callback_method: status_callback_method, **keyword_args))
      end
    end

    ##
    # <Sip> TwiML Noun
    class Sip < TwiML
      def initialize(sip_url, **keyword_args)
        super(**keyword_args)
        @name = 'Sip'
        @value = sip_url
        yield(self) if block_given?
      end
    end

    ##
    # <Sim> TwiML Noun
    class Sim < TwiML
      def initialize(sim_sid, **keyword_args)
        super(**keyword_args)
        @name = 'Sim'
        @value = sim_sid
        yield(self) if block_given?
      end
    end

    ##
    # <Number> TwiML Noun
    class Number < TwiML
      def initialize(phone_number, **keyword_args)
        super(**keyword_args)
        @name = 'Number'
        @value = phone_number
        yield(self) if block_given?
      end
    end

    ##
    # <Conference> TwiML Noun
    class Conference < TwiML
      def initialize(name, **keyword_args)
        super(**keyword_args)
        @name = 'Conference'
        @value = name
        yield(self) if block_given?
      end
    end

    ##
    # <Client> TwiML Noun
    class Client < TwiML
      def initialize(identity: nil, **keyword_args)
        super(**keyword_args)
        @name = 'Client'
        @value = identity unless identity.nil?
        yield(self) if block_given?
      end

      ##
      # Create a new <Identity> element
      # client_identity:: Identity of the client to dial
      # keyword_args:: additional attributes
      def identity(client_identity, **keyword_args)
        append(Identity.new(client_identity, **keyword_args))
      end

      ##
      # Create a new <Parameter> element
      # name:: The name of the custom parameter
      # value:: The value of the custom parameter
      # keyword_args:: additional attributes
      def parameter(name: nil, value: nil, **keyword_args)
        append(Parameter.new(name: name, value: value, **keyword_args))
      end
    end

    ##
    # <Identity> TwiML Noun
    class Identity < TwiML
      def initialize(client_identity, **keyword_args)
        super(**keyword_args)
        @name = 'Identity'
        @value = client_identity
        yield(self) if block_given?
      end
    end

    ##
    # <Connect> TwiML Verb
    class Connect < TwiML
      def initialize(**keyword_args)
        super(**keyword_args)
        @name = 'Connect'

        yield(self) if block_given?
      end

      ##
      # Create a new <Room> element
      # name:: Room name
      # participant_identity:: Participant identity when connecting to the Room
      # keyword_args:: additional attributes
      def room(name, participant_identity: nil, **keyword_args)
        append(Room.new(name, participant_identity: participant_identity, **keyword_args))
      end

      ##
      # Create a new <Autopilot> element
      # name:: Autopilot assistant sid or unique name
      # keyword_args:: additional attributes
      def autopilot(name, **keyword_args)
        append(Autopilot.new(name, **keyword_args))
      end

      ##
      # Create a new <Stream> element
      # name:: Friendly name given to the Stream
      # connector_name:: Unique name for Stream Connector
      # url:: URL of the remote service where the Stream is routed
      # track:: Track to be streamed to remote service
      # status_callback:: Status Callback URL
      # status_callback_method:: Status Callback URL method
      # keyword_args:: additional attributes
      def stream(name: nil, connector_name: nil, url: nil, track: nil, status_callback: nil, status_callback_method: nil, **keyword_args)
        stream = Stream.new(name: name, connector_name: connector_name, url: url, track: track, status_callback: status_callback, status_callback_method: status_callback_method, **keyword_args)

        yield(stream) if block_given?
        append(stream)
      end
    end

    ##
    # <Autopilot> TwiML Noun
    class Autopilot < TwiML
      def initialize(name, **keyword_args)
        super(**keyword_args)
        @name = 'Autopilot'
        @value = name
        yield(self) if block_given?
      end
    end

    ##
    # <Room> TwiML Noun
    class Room < TwiML
      def initialize(name, **keyword_args)
        super(**keyword_args)
        @name = 'Room'
        @value = name
        yield(self) if block_given?
      end
    end
  end
end